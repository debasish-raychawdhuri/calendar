impl Database {
    pub async fn migrate_database(&self) -> Result<(), DbError> {
        println!("Running database migrations...");
        
        // Add google_id column if it doesn't exist
        self.conn.execute(
            "ALTER TABLE events ADD COLUMN IF NOT EXISTS google_id TEXT;",
            [],
        ).map_err(DbError::DatabaseError)?;
        
        println!("Migrations completed successfully.");
        Ok(())
    }
    
    // Find an event by Google ID
    pub async fn find_event_by_google_id(&self, google_id: &str) -> Result<Option<Event>, DbError> {
        let mut stmt = self.conn.prepare(
            "SELECT id, title, description, date, created_at, start_time, duration_minutes, google_id FROM events WHERE google_id = ?1"
        ).map_err(DbError::DatabaseError)?;
        
        let event_result = stmt.query_row(params![google_id], |row| {
            let date_str: String = row.get(3)?;
            let created_at_str: String = row.get(4)?;
            
            let date = NaiveDate::parse_from_str(&date_str, "%Y-%m-%d")
                .map_err(|_| rusqlite::Error::InvalidParameterName("Invalid date format".to_string()))?;
            
            let created_at = DateTime::parse_from_rfc3339(&created_at_str)
                .map(|dt| dt.with_timezone(&Utc))
                .map_err(|_| rusqlite::Error::InvalidParameterName("Invalid datetime format".to_string()))?;
            
            let start_time_str: Option<String> = row.get(5)?;
            let start_time = start_time_str.and_then(|s| NaiveTime::parse_from_str(&s, "%H:%M:%S").ok());
            
            let duration_minutes: Option<i32> = row.get(6)?;
            let google_id: Option<String> = row.get(7)?;
            
            Ok(Event {
                id: Some(row.get(0)?),
                title: row.get(1)?,
                description: row.get(2)?,
                date,
                start_time,
                duration_minutes,
                created_at: Some(created_at),
                google_id,
            })
        });
        
        match event_result {
            Ok(event) => Ok(Some(event)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(DbError::DatabaseError(e)),
        }
    }
    
    // Delete all events with Google IDs that are not in the provided list
    pub async fn delete_missing_google_events(&self, google_ids: &[String]) -> Result<usize, DbError> {
        let placeholders = google_ids.iter()
            .enumerate()
            .map(|(i, _)| format!("?{}", i + 1))
            .collect::<Vec<_>>()
            .join(",");
        
        let mut params: Vec<&dyn rusqlite::ToSql> = Vec::new();
        for id in google_ids {
            params.push(id);
        }
        
        let query = if !google_ids.is_empty() {
            format!("DELETE FROM events WHERE google_id IS NOT NULL AND google_id NOT IN ({})", placeholders)
        } else {
            "DELETE FROM events WHERE google_id IS NOT NULL".to_string()
        };
        
        let rows_affected = self.conn.execute(&query, rusqlite::params_from_iter(params))
            .map_err(DbError::DatabaseError)?;
        
        Ok(rows_affected)
    }
}
